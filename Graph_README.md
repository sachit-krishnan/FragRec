# Graph_README:

Graph - specifically, directed graph - is the primary data structure I am working with on my project. Both the nodes and the edges of the graph are of the dictionary data type. The graph contains two types of nodes/vertices:
  1. Fragrance nodes: These nodes are defined as a key-value pair of the fragrance name and the Fragrance object.
  2. Attribute nodes: These nodes are defined as a key-value pair of the unique fragrance attributes (keys) and their corresponding names. For most attribute categories, the key and the value of the attribute node are identical - which suggests that a list may have been sufficient to represent these nodes. However, a problem arises when the fragrance note attributes are required to be mapped to their 'values'. For instance, while a 'sandalwood' note will always be a 'sandalwood' note, it is important to ascertain whether it is the top, the middle, or the base note of a given fragrance. Without loss of generality, assuming that it is the base note, its corresponding node would be defined as {'sandalwood (BASE)' : 'sandalwood'}. The additional identifier '(BASE)' helps differentiate the base note sandalwood from, say, a middle note sandalwood. This differentiation is crucial because, without it, a user requesting a perfume with a sandalwood base note may very well be recommended a perfume with a sandalwood top note.

The edges of the graph are constructed between attribute nodes and fragrance nodes. Simply put, every fragrance is mapped to all of its attributes, and every attribute is mapped to all of the fragrances that it is an attribute of. The direction of the edges is from the attribute node to the fragrance. More specifically, every attribute node has an edge toward every fragrance node whose attribute it is. For instance, the node {'Yves Saint Laurent' : 'Yves Saint Laurent'} has every Yves Saint Laurent fragrance in my database as its neighbor (and none other), and the node {'mint (TOP)' : 'mint'} has all the fragrances that have mint as one of their top notes as its neighbor (and none other).

The reason for the directed nature of the graph is straightforward - I only need to map in one direction, i.e., from the attributes to the fragrances. When a user selects certain attribute values, I map them back to the attribute keys thanks to the nature of the attribute nodes, and then map the attribute nodes to the fragrance nodes in order to make recommendations.

The Graph data structure enables me to efficiently look for fragrances when I receive a query with some attributes from the user, for all I have to do is inspect the neighbors of the given attribute nodes, process my observed list, and return it to the user in a pretty way.
